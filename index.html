<!doctype html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>YouTube 一括取得・整形（連番＋リンク＋チャンネル統計）</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans JP",sans-serif;margin:24px;line-height:1.7}
  h1{font-size:1.2rem;margin:0 0 12px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin:8px 0}
  input,button,select,textarea{font-size:14px}
  input,button,select{padding:8px}
  input[type="number"]{width:120px}
  input[type="date"]{width:auto}
  textarea{width:100%;min-height:260px;padding:10px}
  .muted{color:#6b7280}
  .pill{border:1px solid #d1d5db;border-radius:999px;padding:6px 10px}
  .section{border:1px solid #e5e7eb;border-radius:10px;padding:12px;margin:12px 0}
  .hide{display:none}
</style>

<h1>YouTube 一括取得・整形（連番＋リンク＋チャンネル統計）</h1>

<script>
// 公開環境では空が安全。ローカル用途のみ埋めてもOK
const DEFAULT_API_KEY = '';
</script>

<!-- 動作モード -->
<div class="row">
  <span class="pill"><label><input type="radio" name="work" value="collect" checked> 取得モード</label></span>
  <span class="pill"><label><input type="radio" name="work" value="format"> 整形モード</label></span>
</div>

<!-- API/GAS 設定 -->
<div class="section">
  <div class="row">
    <span class="pill"><label><input type="radio" name="mode" value="client" checked> 直接API</label></span>
    <span class="pill"><label><input type="radio" name="mode" value="gas"> GASバックエンド</label></span>
    <span class="muted">※ 整形モードはAPIキーを使います（GAS不要）</span>
  </div>

  <div class="row" id="apiRow">
    <label>APIキー：</label>
    <input id="apiKey" placeholder="YouTube Data API v3 の APIキー" style="min-width:260px;flex:1">
    <button id="saveKey">保存</button>
    <span class="muted">（ブラウザにローカル保存）</span>
  </div>

  <div class="row hide" id="gasRow">
    <label>GAS APP_URL（/exec）：</label>
    <input id="appUrl" placeholder="https://script.google.com/macros/s/xxxxxxxxxxxxxxxx/exec" style="min-width:360px;flex:1">
    <span class="muted">※ /dev ではなく /exec を指定</span>
  </div>
</div>

<!-- 入力UI（取得モード） -->
<div class="section" id="collectBox">
  <div class="row">
    <label>チャンネル/PL/URL：</label>
    <input id="channel" placeholder="@handle / UCxxxxxxxx... / https://.../@handle / 動画URL / プレイリストURL" style="min-width:320px;flex:1">
  </div>
  <div class="row">
    <label>最大件数：</label>
    <input id="limit" type="number" value="200" min="1" max="5000">
    <label>公開日 since：</label>
    <input id="since" type="date">
    <label>並び順：</label>
    <select id="sort">
      <option value="newest" selected>新しい順</option>
      <option value="oldest">古い順</option>
      <option value="none">そのまま</option>
    </select>
  </div>
  <div class="row">
    <button id="runCollect">取得 → 整形</button>
  </div>
</div>

<!-- 入力UI（整形モード） -->
<div class="section hide" id="formatBox">
  <div class="row"><label class="muted">動画URLを改行/スペース区切りで貼り付け</label></div>
  <textarea id="rawUrls" placeholder="例）https://www.youtube.com/watch?v=dQw4w9WgXcQ&#10;https://youtu.be/XXXXXXXXXXX&#10;..."></textarea>
  <div class="row">
    <label>公開日 since：</label>
    <input id="since2" type="date">
    <label>並び順：</label>
    <select id="sort2">
      <option value="none" selected>入力順のまま</option>
      <option value="newest">新しい順</option>
      <option value="oldest">古い順</option>
    </select>
  </div>
  <div class="row">
    <button id="runFormat">整形する</button>
  </div>
</div>

<!-- 出力設定 -->
<div class="section">
  <div class="row">
    <label>出力形式：</label>
    <select id="format">
      <option value="html" selected>HTML（リッチ）</option>
      <option value="md">Markdown（リッチ）</option>
      <option value="tsv">TSV（タブ区切り）</option>
      <option value="csv">CSV（カンマ区切り）</option>
    </select>
    <label>開始番号：</label>
    <input id="startNum" type="number" value="1" min="1">
    <span class="muted">件数：</span><span id="count" class="pill">0 件</span>
    <span id="status" class="muted"></span>
  </div>
  <p class="muted">各行は <strong>連番. タイトル(リンク) — 視聴回数(リンク) — 公開日</strong>。ヘッダにチャンネル統計（登録者/総再生/動画数）を表示します。</p>
  <textarea id="out" placeholder="ここに結果が出ます"></textarea>
  <div class="row">
    <button id="copy">コピー</button>
    <button id="dlCsv">CSVダウンロード</button>
  </div>
</div>

<script>
/* ========== 参照 ========== */
const apiKeyInput = document.getElementById('apiKey');
const appUrlInput = document.getElementById('appUrl');
const apiRow      = document.getElementById('apiRow');
const gasRow      = document.getElementById('gasRow');

const collectBox  = document.getElementById('collectBox');
const formatBox   = document.getElementById('formatBox');

const channelInput= document.getElementById('channel');
const limitInput  = document.getElementById('limit');
const sinceInput  = document.getElementById('since');
const sortSelect  = document.getElementById('sort');
const runCollect  = document.getElementById('runCollect');

const rawUrlsTA   = document.getElementById('rawUrls');
const since2Input = document.getElementById('since2');
const sort2Select = document.getElementById('sort2');
const runFormat   = document.getElementById('runFormat');

const fmtSelect   = document.getElementById('format');
const startNumInp = document.getElementById('startNum');

const outTA       = document.getElementById('out');
const copyBtn     = document.getElementById('copy');
const dlCsvBtn    = document.getElementById('dlCsv');
const statusEl    = document.getElementById('status');
const countEl     = document.getElementById('count');

/* ========== 保存/復元 ========== */
apiKeyInput.value = localStorage.getItem('yt_api_key') || DEFAULT_API_KEY || '';
appUrlInput.value = localStorage.getItem('yt_app_url') || '';
document.getElementById('saveKey').onclick = () => {
  localStorage.setItem('yt_api_key', apiKeyInput.value.trim());
  flash('APIキーを保存しました');
};
appUrlInput.addEventListener('change', () => {
  localStorage.setItem('yt_app_url', appUrlInput.value.trim());
});

/* ========== モード切替 ========== */
function getApiMode(){ return document.querySelector('input[name="mode"]:checked').value; }
function getWorkMode(){ return document.querySelector('input[name="work"]:checked').value; }
for (const r of document.querySelectorAll('input[name="mode"],input[name="work"]')) r.addEventListener('change', syncVisibility);
function syncVisibility(){
  const apiMode  = getApiMode();  // client | gas
  const workMode = getWorkMode(); // collect | format
  apiRow.classList.toggle('hide', apiMode !== 'client');
  gasRow.classList.toggle('hide', apiMode !== 'gas');
  collectBox.classList.toggle('hide', workMode !== 'collect');
  formatBox.classList.toggle('hide', workMode !== 'format');
  outTA.value=''; setCount(0); statusEl.textContent='';
}
syncVisibility();

/* ========== 実行（取得モード） ========== */
runCollect.onclick = async () => {
  const apiMode = getApiMode();
  const raw  = channelInput.value.trim();
  const max  = Math.max(1, Math.min(5000, Number(limitInput.value) || 200));
  const since= sinceInput.value;
  const sort = sortSelect.value;
  const startNo = Math.max(1, Number(startNumInp.value)||1);
  if (!raw) return alert('チャンネル/プレイリスト/URLを入力してください');

  try {
    setBusy(true); setCount('—');
    let rows = [];
    let channelSummary = null;

    if (apiMode === 'gas') {
      const app = validateExecUrlOrThrow(appUrlInput.value.trim());
      const result = await runViaGAS(app, raw, { max, since, sort });
      rows = result.rows;
      // GAS応答に channelId があれば、APIキーがある場合のみ統計取得（任意）
      if (result.channelId && apiKeyInput.value.trim()) {
        channelSummary = await getChannelStats(result.channelId, apiKeyInput.value.trim());
      }
    } else {
      const key = getKeyOrThrow();
      const { rows: r, channel: ch } = await runViaClient(key, raw, { max, since, sort });
      rows = r; channelSummary = ch;
    }

    renderOutput(rows, startNo, channelSummary);
  } catch (e) {
    console.error(e);
    setCount(0);
    alert('エラー: ' + (e.message || e));
  } finally {
    setBusy(false);
  }
};

/* ========== 実行（整形モード） ========== */
runFormat.onclick = async () => {
  const text = rawUrlsTA.value;
  const ids  = extractVideoIds(text);
  if (!ids.length) return alert('動画URLが見つかりませんでした');
  const key   = getKeyOrThrow();
  const since = since2Input.value;
  const sort  = sort2Select.value;
  const startNo = Math.max(1, Number(startNumInp.value)||1);

  try {
    setBusy(true); setCount('—');
    const details = await fetchVideosDetails(ids, key); // Map<id,{title,viewCount,publishedAt}>
    let rows = ids.map(id => {
      const d = details.get(id) || {};
      return { url:`https://www.youtube.com/watch?v=${id}`, viewCount:d.viewCount ?? null, title:d.title ?? '', publishedAt:d.publishedAt ?? '' };
    });
    rows = applySinceAndSort(rows, { since, sort });
    renderOutput(rows, startNo, null);
  } catch(e){
    console.error(e);
    setCount(0);
    alert('エラー: ' + (e.message || e));
  } finally {
    setBusy(false);
  }
};

/* ========== 出力レンダリング ========== */
function renderOutput(rows, startNo, channel){
  const fmt = fmtSelect.value; // html|md|tsv|csv
  outTA.value = rowsToFormattedText(rows, fmt, startNo, channel);
  setCount(rows.length);
  flash(`${rows.length}件を整形しました`);
}

/* ========== 共通ユーティリティ ========== */
function setBusy(b, msg){ statusEl.textContent = b ? (msg || '処理中…') : ''; }
function flash(msg){ statusEl.textContent = msg; setTimeout(()=> statusEl.textContent='', 1600); }
function setCount(n){ countEl.textContent = (n==='—') ? '—' : `${Number(n)||0} 件`; }
function getKeyOrThrow(){ const key=apiKeyInput.value.trim(); if(!key) throw new Error('APIキーを入力してください'); return key; }

/* ==== 直接API（ブラウザ） ==== */
async function runViaClient(key, raw, {max, since, sort}) {
  const channelId = await resolveChannelIdSmart(raw, key);
  if (!channelId) throw new Error('チャンネルIDを解決できませんでした');

  // チャンネル統計
  const channel = await getChannelStats(channelId, key);

  const uploads = await getUploadsPlaylistId(channelId, key);
  if (!uploads) throw new Error('アップロード済みプレイリストが見つかりませんでした');

  const videoIds = await listPlaylistVideoIds(uploads, key, max);
  const details = await fetchVideosDetails(videoIds, key);

  let rows = videoIds.map(id => {
    const d = details.get(id) || {};
    return { url:`https://www.youtube.com/watch?v=${id}`, viewCount:d.viewCount ?? null, title:d.title ?? '', publishedAt:d.publishedAt ?? '' };
  });

  rows = applySinceAndSort(rows, { since, sort });
  return { rows, channel };
}

/* ==== GAS経由（取得モード用） ==== */
async function runViaGAS(appUrl, channelInput, {max, since, sort}){
  const url = new URL(appUrl);
  url.searchParams.set('max', String(max));
  if (since) url.searchParams.set('since', since);
  if (/^UC[0-9A-Za-z_-]{22}$/.test(channelInput)) url.searchParams.set('channelId', channelInput);
  else url.searchParams.set('channel', channelInput);

  try {
    const json = await fetchJson(url.toString());
    return normalizeFromBackend(json, sort, since);
  } catch (_) {
    const json = await jsonpFetch(url);
    return normalizeFromBackend(json, sort, since);
  }
}
function normalizeFromBackend(json, sort, since){
  if (!json || json.ok === false) throw new Error(json?.error || 'GAS応答エラー');
  let rows = (json.items || []).map(it => ({
    url: it.url || '',
    viewCount: (it.viewCount != null) ? Number(it.viewCount) : null,
    title: it.title || '',
    publishedAt: it.publishedAt || ''
  }));
  rows = applySinceAndSort(rows, { since, sort });
  return { rows, channelId: json.channelId || null };
}

/* ==== 並び替え・フィルタ ==== */
function applySinceAndSort(rows, {since, sort}) {
  if (since) {
    const t0 = new Date(`${since}T00:00:00Z`).getTime();
    if (isFinite(t0)) rows = rows.filter(r => {
      const t = new Date(r.publishedAt || 0).getTime();
      return isFinite(t) && t >= t0;
    });
  }
  if (sort === 'newest' || sort === 'oldest') {
    rows.sort((a,b) => {
      const ta = new Date(a.publishedAt || 0).getTime();
      const tb = new Date(b.publishedAt || 0).getTime();
      return sort === 'newest' ? (tb - ta) : (ta - tb);
    });
  }
  return rows;
}

/* ==== 整形（凝ったテンプレ） ==== */
function rowsToFormattedText(rows, fmt, startNo, channel){
  const num = (i)=> String(startNo + i);
  const header = formatChannelHeader(channel, fmt);
  if (fmt === 'html') {
    // HTMLリッチ：ヘッダ＋<ol>
    const list = rows.map((r,i)=>{
      const views = (r.viewCount!=null)? Number(r.viewCount).toLocaleString('ja-JP')+'回' : '';
      const date  = r.publishedAt ? r.publishedAt.slice(0,10) : '';
      return `<li><a href="${r.url}" target="_blank" rel="noopener">${escapeHtml(r.title)}</a> — <a href="${r.url}" target="_blank" rel="noopener">${views}</a> — <time>${escapeHtml(date)}</time></li>`;
    }).join('\n');
    return `${header}\n<ol start="${startNo}">\n${list}\n</ol>`;
  }
  if (fmt === 'md') {
    // Markdownリッチ：ヘッダ＋番号リスト
    const list = rows.map((r,i)=>{
      const views = (r.viewCount!=null)? Number(r.viewCount).toLocaleString('ja-JP')+'回' : '';
      const date  = r.publishedAt ? r.publishedAt.slice(0,10) : '';
      return `${num(i)}. [${r.title}](${r.url}) — [${views}](${r.url}) — ${date}`;
    }).join('\n');
    return `${header}\n${list}`;
  }
  // TSV/CSV：先頭にメタ2行 + 表
  const sep = (fmt==='csv') ? ',' : '\t';
  const esc = (s)=> {
    s = String(s??'');
    if (fmt==='csv' && /[",\n]/.test(s)) s = `"${s.replace(/"/g,'""')}"`;
    return s;
  };
  const meta = formatChannelMetaRow(channel, sep, esc);
  const head = ['No','URL','視聴回数','タイトル','公開日'];
  const lines = [meta, head.join(sep)];
  rows.forEach((r,i)=>{
    const views = (r.viewCount!=null)? Number(r.viewCount).toLocaleString('ja-JP') : '';
    const date  = r.publishedAt ? r.publishedAt.slice(0,10) : '';
    lines.push([num(i), r.url, views, r.title, date].map(esc).join(sep));
  });
  return lines.filter(Boolean).join('\n');
}

function formatChannelHeader(ch, fmt){
  if (!ch) return (fmt==='md') ? '### （チャンネル統計なし）' : '<!-- no channel header -->';
  const subs  = (ch.subscriberCount!=null)? Number(ch.subscriberCount).toLocaleString('ja-JP') : '非公開';
  const views = (ch.viewCount!=null)? Number(ch.viewCount).toLocaleString('ja-JP') : '-';
  const vids  = (ch.videoCount!=null)? Number(ch.videoCount).toLocaleString('ja-JP') : '-';
  if (fmt==='md') {
    return `### [${ch.title}](${ch.url})\n登録者数: **${subs}** / 総再生: **${views}** / 動画数: **${vids}**`;
  }
  // HTML
  return `<section>
  <h2><a href="${ch.url}" target="_blank" rel="noopener">${escapeHtml(ch.title)}</a></h2>
  <p>登録者数: <strong>${subs}</strong> / 総再生: <strong>${views}</strong> / 動画数: <strong>${vids}</strong></p>
</section>`;
}
function formatChannelMetaRow(ch, sep, esc){
  if (!ch) return '';
  const subs  = (ch.subscriberCount!=null)? Number(ch.subscriberCount).toLocaleString('ja-JP') : '非公開';
  const views = (ch.viewCount!=null)? Number(ch.viewCount).toLocaleString('ja-JP') : '-';
  const vids  = (ch.videoCount!=null)? Number(ch.videoCount).toLocaleString('ja-JP') : '-';
  const head = ['# Channel','URL','Subscribers','TotalViews','TotalVideos'].join(sep);
  const row  = [ch.title, ch.url, subs, views, vids].map(esc).join(sep);
  return head + '\n' + row;
}

function escapeHtml(s){ return String(s).replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }

/* ==== テキストから動画ID抽出（整形モード用） ==== */
function extractVideoIds(text){
  const set = new Set();
  const tokens = String(text||'').split(/[\s\n\r\t]+/).filter(Boolean);
  const re = /(?:v=|vi=|v%3D|youtu\.be\/|shorts\/|embed\/)([0-9A-Za-z_-]{11})/;
  for (const tk of tokens){
    if (/^https?:\/\//i.test(tk)) {
      try {
        const u = new URL(tk);
        const host = u.hostname.replace(/^www\./,'');
        const parts = u.pathname.replace(/\/+$/,'').split('/').filter(Boolean);
        let id = u.searchParams.get('v');
        if (!id && host==='youtu.be') id = parts[0];
        if (!id && ['shorts','embed','live'].includes(parts[0])) id = parts[1];
        if (id && /^[0-9A-Za-z_-]{11}$/.test(id)) { set.add(id); continue; }
      } catch {}
      const m = tk.match(re); if (m && m[1]) { set.add(m[1]); continue; }
    }
    if (/^[0-9A-Za-z_-]{11}$/.test(tk)) set.add(tk);
    else { const m = tk.match(re); if (m && m[1]) set.add(m[1]); }
  }
  return Array.from(set);
}

/* ==== Web API ==== */
async function fetchJson(u){
  const res = await fetch(u, {cache:'no-store',mode:'cors',credentials:'omit'});
  const ct  = (res.headers.get('content-type')||'').toLowerCase();
  const txt = await res.text();
  if (!res.ok) throw new Error(`HTTP ${res.status} / ${txt.slice(0,200)}`);
  if (!ct.includes('application/json')) throw new Error(`JSON以外の応答: ${ct} / ${txt.slice(0,160)}`);
  return JSON.parse(txt);
}
function jsonpFetch(urlObj){
  return new Promise((resolve,reject)=>{
    const u = new URL(urlObj.toString());
    const cb = '__jsonp_cb_' + Date.now() + '_' + Math.floor(Math.random()*1e6);
    u.searchParams.set('callback', cb);
    const timer = setTimeout(()=>{cleanup();reject(new Error('JSONPタイムアウト'));},15000);
    function cleanup(){clearTimeout(timer);try{delete window[cb];}catch{} if (script&&script.parentNode) script.parentNode.removeChild(script);}
    window[cb] = data => {cleanup();resolve(data);};
    const script = document.createElement('script');
    script.src = u.toString();
    script.onerror = ()=>{cleanup();reject(new Error('JSONP読込失敗'));};
    document.head.appendChild(script);
  });
}

/* ==== YouTube API 呼び出し ==== */
async function getChannelStats(channelId, key){
  const ep = new URL('https://www.googleapis.com/youtube/v3/channels');
  ep.searchParams.set('part','snippet,statistics');
  ep.searchParams.set('id', channelId);
  ep.searchParams.set('key', key);
  const r = await fetch(ep); await assertOk_(r, 'channels(stats) API');
  const j = await r.json();
  const it = j.items?.[0];
  const sn = it?.snippet || {};
  const st = it?.statistics || {};
  const custom = (sn.customUrl || '').replace(/^\/+/,''); // '@handle' or 'c/xxx' 等
  const url = custom ? `https://www.youtube.com/${custom}` : `https://www.youtube.com/channel/${channelId}`;
  return {
    channelId,
    title: sn.title || '',
    url,
    subscriberCount: (st.hiddenSubscriberCount ? null : (st.subscriberCount ? Number(st.subscriberCount) : null)),
    viewCount: st.viewCount ? Number(st.viewCount) : null,
    videoCount: st.videoCount ? Number(st.videoCount) : null
  };
}

async function getChannelIdFromVideo(videoId, key) {
  const ep = new URL('https://www.googleapis.com/youtube/v3/videos');
  ep.searchParams.set('part','snippet');
  ep.searchParams.set('id', videoId);
  ep.searchParams.set('key', key);
  const r = await fetch(ep); await assertOk_(r, 'videos API');
  const j = await r.json();
  return j.items?.[0]?.snippet?.channelId || null;
}
async function getChannelIdFromPlaylist(playlistId, key) {
  const ep = new URL('https://www.googleapis.com/youtube/v3/playlists');
  ep.searchParams.set('part','snippet');
  ep.searchParams.set('id', playlistId);
  ep.searchParams.set('key', key);
  const r = await fetch(ep); await assertOk_(r, 'playlists API');
  const j = await r.json();
  return j.items?.[0]?.snippet?.channelId || null;
}
async function searchChannelIdByHandle(handle, key) {
  const ep = new URL('https://www.googleapis.com/youtube/v3/search');
  ep.searchParams.set('part','snippet');
  ep.searchParams.set('type','channel');
  ep.searchParams.set('q', handle);
  ep.searchParams.set('maxResults','1');
  ep.searchParams.set('key', key);
  const r = await fetch(ep); await assertOk_(r, 'search(handle) API');
  const j = await r.json();
  return j.items?.[0]?.id?.channelId || null;
}
async function searchChannelIdByQuery(query, key) {
  const ep = new URL('https://www.googleapis.com/youtube/v3/search');
  ep.searchParams.set('part','snippet');
  ep.searchParams.set('type','channel');
  ep.searchParams.set('q', query);
  ep.searchParams.set('maxResults','1');
  ep.searchParams.set('key', key);
  const r = await fetch(ep); await assertOk_(r, 'search(query) API');
  const j = await r.json();
  return j.items?.[0]?.id?.channelId || null;
}
async function getUploadsPlaylistId(channelId, key) {
  const ep = new URL('https://www.googleapis.com/youtube/v3/channels');
  ep.searchParams.set('part', 'contentDetails');
  ep.searchParams.set('id', channelId);
  ep.searchParams.set('key', key);
  const r = await fetch(ep); await assertOk_(r, 'channels API');
  const j = await r.json();
  return j.items?.[0]?.contentDetails?.relatedPlaylists?.uploads || null;
}
async function listPlaylistVideoIds(playlistId, key, maxCount) {
  let ids = []; let pageToken = '';
  while (ids.length < maxCount) {
    const ep = new URL('https://www.googleapis.com/youtube/v3/playlistItems');
    ep.searchParams.set('part', 'contentDetails');
    ep.searchParams.set('playlistId', playlistId);
    ep.searchParams.set('maxResults', '50');
    if (pageToken) ep.searchParams.set('pageToken', pageToken);
    ep.searchParams.set('key', key);
    const r = await fetch(ep); await assertOk_(r, 'playlistItems API');
    const j = await r.json();
    for (const it of (j.items || [])) {
      const id = it.contentDetails?.videoId;
      if (id) ids.push(id);
      if (ids.length >= maxCount) break;
    }
    pageToken = j.nextPageToken || '';
    if (!pageToken) break;
    setBusy(true, `取得中… ${ids.length}件`);
  }
  return ids;
}
async function fetchVideosDetails(videoIds, key) {
  const map = new Map();
  for (let i = 0; i < videoIds.length; i += 50) {
    const chunk = videoIds.slice(i, i + 50);
    const ep = new URL('https://www.googleapis.com/youtube/v3/videos');
    ep.searchParams.set('part', 'snippet,statistics');
    ep.searchParams.set('id', chunk.join(','));
    ep.searchParams.set('key', key);
    const r = await fetch(ep); await assertOk_(r, 'videos(details) API');
    const j = await r.json();
    for (const it of (j.items || [])) {
      map.set(it.id, {
        title: it.snippet?.title ?? '',
        viewCount: it.statistics?.viewCount != null ? Number(it.statistics.viewCount) : null,
        publishedAt: it.snippet?.publishedAt ?? ''
      });
    }
  }
  return map;
}
/* ==== チャンネルID解決 ==== */
function looksLikeUrl(s){ return /^https?:\/\//i.test(String(s||'')); }
async function resolveChannelIdSmart(input, key) {
  const raw = String(input||'').trim(); if (!raw) return null;
  if (/^UC[0-9A-Za-z_-]{22}$/.test(raw)) return raw;
  if (/^[0-9A-Za-z_-]{11}$/.test(raw)) { const cid = await getChannelIdFromVideo(raw, key); if (cid) return cid; }
  if (raw.startsWith('@')) { const cid = await searchChannelIdByHandle(raw.slice(1), key); if (cid) return cid; }
  if (looksLikeUrl(raw)) {
    try {
      const u = new URL(raw);
      const host = u.hostname.replace(/^www\./,'');
      const parts = u.pathname.replace(/\/+$/,'').split('/').filter(Boolean);
      const vid = u.searchParams.get('v') || (['shorts','embed','live'].includes(parts[0]) ? parts[1] : null);
      if (host==='youtu.be' && parts[0]) { const cid = await getChannelIdFromVideo(parts[0].slice(0,11), key); if (cid) return cid; }
      if (vid) { const cid = await getChannelIdFromVideo(vid.slice(0,11), key); if (cid) return cid; }
      const list = u.searchParams.get('list'); if (list) { const cid = await getChannelIdFromPlaylist(list, key); if (cid) return cid; }
      const mCh = u.pathname.match(/\/channel\/(UC[0-9A-Za-z_-]{22})$/); if (mCh) return mCh[1];
      const mHandle = u.pathname.match(/\/@([^/]+)$/); if (mHandle) { const cid = await searchChannelIdByHandle(mHandle[1], key); if (cid) return cid; }
      const mCustom = u.pathname.match(/\/(c|user)\/([^/]+)$/); if (mCustom) { const cid = await searchChannelIdByQuery(mCustom[2], key); if (cid) return cid; }
    } catch {}
  }
  return await searchChannelIdByQuery(raw, key);
}

/* ==== ヘルパ ==== */
async function assertOk_(res, label){
  if (res.ok) return;
  let detail=''; try{ detail=' / '+(await res.text()).slice(0,200);}catch{}
  throw new Error(`${label} エラー: ${res.status}${detail}`);
}
function validateExecUrlOrThrow(s){
  const m = String(s||'').match(/https?:\/\/script\.google\.com\/macros\/s\/[A-Za-z0-9_-]+\/exec/);
  if (!m) throw new Error('GASの APP_URL（/exec）を正しく入力してください');
  return m[0];
}

/* ==== ツールバー ==== */
document.getElementById('copy').onclick = async () => {
  try { await navigator.clipboard.writeText(outTA.value); flash('コピーしました'); }
  catch { alert('コピーに失敗しました'); }
};
document.getElementById('dlCsv').onclick = () => {
  const text = outTA.value || '';
  const blob = new Blob([new Uint8Array([0xEF,0xBB,0xBF]), text.replace(/\t/g, ',')], { type: 'text/csv' });
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `youtube_links_${Date.now()}.csv`;
  document.body.appendChild(a); a.click(); a.remove();
};
</script>
