<!doctype html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>YouTube 一括取得・整形（統計＋並び替えフル）</title>
<style>
  :root{--muted:#6b7280;--bd:#e5e7eb}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans JP",sans-serif;margin:24px;line-height:1.7}
  h1{font-size:1.2rem;margin:0 0 12px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin:8px 0}
  input,button,select,textarea{font-size:14px}
  input,button,select{padding:8px}
  input[type="number"]{width:120px}
  input[type="date"]{width:auto}
  textarea{width:100%;min-height:260px;padding:10px}
  .muted{color:var(--muted)}
  .pill{border:1px solid #d1d5db;border-radius:999px;padding:6px 10px}
  .section{border:1px solid var(--bd);border-radius:10px;padding:12px;margin:12px 0}
  .hide{display:none}
  .preview{border:1px dashed var(--bd);border-radius:10px;padding:12px;margin-top:8px}
</style>

<h1>YouTube 一括取得・整形（統計＋並び替えフル）</h1>

<script>
// 公開環境では空が安全（ローカル用途のみ値を入れてOK）
const DEFAULT_API_KEY = 'AIzaSyAsoGsbekSs5kfzjfIdxmuOdo44hwDqq3g';
</script>

<!-- 動作モード -->
<div class="row">
  <span class="pill">
    <label><input type="radio" name="work" value="collect" checked> 取得モード（チャンネル/PLから取得）</label>
  </span>
  <span class="pill">
    <label><input type="radio" name="work" value="format"> 整形モード（貼り付けた動画URLを整形）</label>
  </span>
</div>

<!-- API/GAS 設定 -->
<div class="section">
  <div class="row">
    <span class="pill">
      <label><input type="radio" name="mode" value="client" checked> 直接API</label>
    </span>
    <span class="pill">
      <label><input type="radio" name="mode" value="gas"> GASバックエンド</label>
    </span>
    <span class="muted">※ 整形モードはAPIキーを使います（GASは不要）</span>
  </div>

  <div class="row" id="apiRow">
    <label>APIキー：</label>
    <input id="apiKey" placeholder="YouTube Data API v3 の APIキー" style="min-width:260px;flex:1">
    <button id="saveKey">保存</button>
    <span class="muted">（ブラウザにローカル保存）</span>
  </div>

  <div class="row hide" id="gasRow">
    <label>GAS APP_URL（/exec）：</label>
    <input id="appUrl" placeholder="https://script.google.com/macros/s/xxxxxxxxxxxxxxxx/exec" style="min-width:360px;flex:1">
    <span class="muted">※ /dev ではなく /exec を指定</span>
  </div>
</div>

<!-- 入力UI（取得モード） -->
<div class="section" id="collectBox">
  <div class="row">
    <label>チャンネル/PL/URL：</label>
    <input id="channel" placeholder="@handle / UCxxxxxxxx... / https://.../@handle / 動画URL / プレイリストURL" style="min-width:320px;flex:1">
  </div>
  <div class="row">
    <label>最大件数：</label>
    <input id="limit" type="number" value="200" min="1" max="5000">
    <label>公開日 since：</label>
    <input id="since" type="date">
    <label>取得時の並び：</label>
    <select id="sort">
      <option value="newest" selected>新しい順（公開日）</option>
      <option value="oldest">古い順（公開日）</option>
      <option value="none">そのまま</option>
    </select>
  </div>
  <div class="row">
    <button id="runCollect">取得 → 整形</button>
  </div>
</div>

<!-- 入力UI（整形モード） -->
<div class="section hide" id="formatBox">
  <div class="row"><label class="muted">動画URLを改行/スペース区切りで貼り付け</label></div>
  <textarea id="rawUrls" placeholder="例）https://www.youtube.com/watch?v=dQw4w9WgXcQ&#10;https://youtu.be/XXXXXXXXXXX&#10;..."></textarea>
  <div class="row">
    <label>公開日 since：</label>
    <input id="since2" type="date">
    <label>取得時の並び：</label>
    <select id="sort2">
      <option value="none" selected>入力順のまま</option>
      <option value="newest">新しい順（公開日）</option>
      <option value="oldest">古い順（公開日）</option>
    </select>
  </div>
  <div class="row">
    <button id="runFormat">整形する</button>
  </div>
</div>

<!-- 出力設定 -->
<div class="section">
  <div class="row">
    <label>出力テンプレ：</label>
    <select id="format">
      <option value="html-list" selected>HTML：連番リスト（上にチャンネル統計）</option>
      <option value="html-cards">HTML：カード型（上にチャンネル統計）</option>
      <option value="md">Markdown（見出し＋連番リスト）</option>
      <option value="tsv">TSV（表形式）</option>
      <option value="csv">CSV（表形式）</option>
    </select>

    <!-- ★ 整形後並び替え（視聴回数等） -->
    <label>整形後の並び替え：</label>
    <select id="postSort">
      <option value="none" selected>入力順のまま</option>
      <option value="viewsDesc">視聴回数 多い順</option>
      <option value="viewsAsc">視聴回数 少ない順</option>
      <option value="likesDesc">高評価 多い順</option>
      <option value="likesAsc">高評価 少ない順</option>
      <option value="commentsDesc">コメント 多い順</option>
      <option value="commentsAsc">コメント 少ない順</option>
      <option value="avgDesc">平均/日 多い順</option>
      <option value="avgAsc">平均/日 少ない順</option>
      <option value="growthDesc">推定増分(N日) 多い順</option>
      <option value="growthAsc">推定増分(N日) 少ない順</option>
    </select>

    <label>推定N日：</label>
    <input id="windowDays" type="number" value="28" min="1" style="width:90px">

    <label>開始番号：</label>
    <input id="startNum" type="number" value="1" min="1">

    <span class="muted">件数：</span><span id="count" class="pill">0 件</span>
    <span id="status" class="muted"></span>
  </div>

  <p class="muted">各行は <strong>連番. タイトル(リンク) — 視聴回数(リンク) — 高評価 — コメント — 平均/日 — 推定増分(N日) — 公開日</strong> で出力（形式により最適化）。</p>
  <textarea id="out" placeholder="ここに結果が出ます"></textarea>

  <div class="row">
    <button id="copy">コピー</button>
    <button id="dlCsv">CSVダウンロード</button>
  </div>

  <!-- 簡易プレビュー（HTMLのみ） -->
  <details class="preview" id="previewWrap">
    <summary>HTMLプレビュー（クリックで展開）</summary>
    <div id="preview"></div>
  </details>
</div>

<script>
/* ================== 要素参照 ================== */
const apiKeyInput = document.getElementById('apiKey');
const appUrlInput = document.getElementById('appUrl');
const apiRow      = document.getElementById('apiRow');
const gasRow      = document.getElementById('gasRow');

const collectBox  = document.getElementById('collectBox');
const formatBox   = document.getElementById('formatBox');

const channelInput= document.getElementById('channel');
const limitInput  = document.getElementById('limit');
const sinceInput  = document.getElementById('since');
const sortSelect  = document.getElementById('sort');
const runCollect  = document.getElementById('runCollect');

const rawUrlsTA   = document.getElementById('rawUrls');
const since2Input = document.getElementById('since2');
const sort2Select = document.getElementById('sort2');
const runFormat   = document.getElementById('runFormat');

const fmtSelect   = document.getElementById('format');
const postSortSel = document.getElementById('postSort');
const windowDays  = document.getElementById('windowDays');
const startNumInp = document.getElementById('startNum');

const outTA       = document.getElementById('out');
const copyBtn     = document.getElementById('copy');
const dlCsvBtn    = document.getElementById('dlCsv');
const statusEl    = document.getElementById('status');
const countEl     = document.getElementById('count');
const previewWrap = document.getElementById('previewWrap');
const previewDiv  = document.getElementById('preview');

/* ==== 直近の結果をキャッシュ（整形後並び替えに使う） ==== */
let lastRows = [];       // {url, viewCount, likeCount, commentCount, title, publishedAt, channelId, __idx}
let lastChannel = null;  // {id,title,url,avatar,subscriberCount,viewCount,videoCount}

/* ================== 保存/復元 ================== */
apiKeyInput.value = localStorage.getItem('yt_api_key') || DEFAULT_API_KEY || '';
appUrlInput.value = localStorage.getItem('yt_app_url') || '';
document.getElementById('saveKey').onclick = () => {
  localStorage.setItem('yt_api_key', apiKeyInput.value.trim());
  flash('APIキーを保存しました');
};
appUrlInput.addEventListener('change', () => {
  localStorage.setItem('yt_app_url', appUrlInput.value.trim());
});

/* ================== モード切替 ================== */
function getApiMode(){ return document.querySelector('input[name="mode"]:checked').value; }
function getWorkMode(){ return document.querySelector('input[name="work"]:checked').value; }

for (const r of document.querySelectorAll('input[name="mode"]')) r.addEventListener('change', syncVisibility);
for (const r of document.querySelectorAll('input[name="work"]')) r.addEventListener('change', () => { syncVisibility(); clearOutput(); });

function syncVisibility(){
  const apiMode  = getApiMode();
  const workMode = getWorkMode();
  apiRow.classList.toggle('hide', apiMode !== 'client');
  gasRow.classList.toggle('hide', apiMode !== 'gas');
  collectBox.classList.toggle('hide', workMode !== 'collect');
  formatBox.classList.toggle('hide', workMode !== 'format');
}
syncVisibility();

/* ================== 実行（取得モード） ================== */
runCollect.onclick = async () => {
  const apiMode = getApiMode();
  const raw  = channelInput.value.trim();
  const max  = Math.max(1, Math.min(5000, Number(limitInput.value) || 200));
  const since= sinceInput.value;
  const sort = sortSelect.value;
  if (!raw) return alert('チャンネル/プレイリスト/URLを入力してください');

  try {
    setBusy(true); setCount('—');
    let rows = [], channel = null;

    if (apiMode === 'gas') {
      const app = validateExecUrlOrThrow(appUrlInput.value.trim());
      const payload = await runViaGAS(app, raw, { max, since, sort });
      rows = payload.rows; channel = payload.channel || null;
    } else {
      const key = getKeyOrThrow();
      const { rows: rws, channel: ch } = await runViaClient(key, raw, { max, since, sort });
      rows = rws; channel = ch;
    }

    lastRows = rows.map((r, i) => ({ ...r, __idx: i }));
    lastChannel = channel;

    rerenderFromCache();
    flash(`${rows.length}件を整形しました`);
  } catch (e) {
    console.error(e);
    clearOutput();
    alert('エラー: ' + (e.message || e));
  } finally {
    setBusy(false);
  }
};

/* ================== 実行（整形モード） ================== */
runFormat.onclick = async () => {
  const text = rawUrlsTA.value;
  const ids  = extractVideoIds(text);
  if (!ids.length) return alert('動画URLが見つかりませんでした');

  const key   = getKeyOrThrow();
  const since = since2Input.value;
  const sort  = sort2Select.value;

  try {
    setBusy(true); setCount('—');
    const details = await fetchVideosDetails(ids, key); // Map<id,{title,viewCount,likeCount,commentCount,publishedAt,channelId}>
    let rows = ids.map((id, i) => {
      const d = details.get(id) || {};
      return {
        url:`https://www.youtube.com/watch?v=${id}`,
        viewCount:d.viewCount ?? null,
        likeCount:d.likeCount ?? null,
        commentCount:d.commentCount ?? null,
        title:d.title ?? '',
        publishedAt:d.publishedAt ?? '',
        channelId:d.channelId || '',
        __idx:i
      };
    });
    rows = applySinceAndSort(rows, { since, sort });

    // 同一チャンネルのみ統計表示
    let channel = null;
    const setCh = new Set(rows.map(r=>r.channelId).filter(Boolean));
    if (setCh.size === 1) channel = await fetchChannelInfo(Array.from(setCh)[0], key);

    lastRows = rows;
    lastChannel = channel;

    rerenderFromCache();
    flash(`${rows.length}件を整形しました`);
  } catch(e){
    console.error(e);
    clearOutput();
    alert('エラー: ' + (e.message || e));
  } finally {
    setBusy(false);
  }
};

/* ================== 整形後の並び替え＆再描画 ================== */
postSortSel.addEventListener('change', rerenderFromCache);
fmtSelect.addEventListener('change', rerenderFromCache);
startNumInp.addEventListener('input', rerenderFromCache);
windowDays.addEventListener('input', rerenderFromCache);

function rerenderFromCache(){
  const startNo = Math.max(1, Number(startNumInp.value)||1);
  const postSort = postSortSel.value;
  const win = Math.max(1, Number(windowDays.value)||28);

  // 由来不変の並びを守れるよう __idx を保持しつつコピー
  let rows = lastRows.map(r => ({ ...r }));

  // 推派生指標を計算
  rows = computeDerivedMetrics(rows, win);

  // 整形後並び替え
  rows = applyPostSort(rows, postSort);

  const text = rowsToFormattedText(rows, fmtSelect.value, startNo, lastChannel, win);
  outTA.value = text;
  setCount(rows.length);
  renderPreview(text);
}

function computeDerivedMetrics(rows, winDays){
  const now = Date.now();
  return rows.map(r=>{
    const t = new Date(r.publishedAt || 0).getTime();
    const age = isFinite(t) ? Math.max((now - t) / 86400000, 1/24) : NaN; // 日（最小1時間相当）
    const views = (r.viewCount==null || isNaN(r.viewCount)) ? NaN : Number(r.viewCount);
    const avgPerDay = isNaN(views) || isNaN(age) ? NaN : (views/age);
    const growth = isNaN(avgPerDay) ? NaN : (avgPerDay * Math.min(winDays, Math.max(age,0)));
    return { ...r, __ageDays: age, __avgPerDay: avgPerDay, __growthWin: growth };
  });
}

function applyPostSort(rows, postSort){
  const byNum = (field, asc=true) => (a,b)=>{
    const av = Number(a[field]); const bv = Number(b[field]);
    const aNaN = isNaN(av); const bNaN = isNaN(bv);
    if (aNaN && bNaN) return a.__idx - b.__idx;
    if (aNaN) return 1;
    if (bNaN) return -1;
    return asc ? (av - bv) : (bv - av);
  };
  switch(postSort){
    case 'viewsDesc': return rows.sort(byNum('viewCount', false));
    case 'viewsAsc' : return rows.sort(byNum('viewCount', true));
    case 'likesDesc': return rows.sort(byNum('likeCount', false));
    case 'likesAsc' : return rows.sort(byNum('likeCount', true));
    case 'commentsDesc': return rows.sort(byNum('commentCount', false));
    case 'commentsAsc' : return rows.sort(byNum('commentCount', true));
    case 'avgDesc': return rows.sort(byNum('__avgPerDay', false));
    case 'avgAsc' : return rows.sort(byNum('__avgPerDay', true));
    case 'growthDesc': return rows.sort(byNum('__growthWin', false));
    case 'growthAsc' : return rows.sort(byNum('__growthWin', true));
    default: return rows.sort((a,b)=> a.__idx - b.__idx); // 入力順
  }
}

/* ================== プレビュー（HTMLのみ） ================== */
function renderPreview(text){
  if (!/^html-/.test(fmtSelect.value)) { previewWrap.open=false; previewDiv.innerHTML=''; return; }
  previewDiv.innerHTML = text;
}

/* ================== 共通ユーティリティ ================== */
function clearOutput(){ outTA.value=''; setCount(0); renderPreview(''); }
function setBusy(b, msg){ statusEl.textContent = b ? (msg || '処理中…') : ''; }
function flash(msg){ statusEl.textContent = msg; setTimeout(()=> statusEl.textContent='', 1600); }
function setCount(n){ countEl.textContent = (n==='—') ? '—' : `${Number(n)||0} 件`; }
function getKeyOrThrow(){ const key = apiKeyInput.value.trim(); if (!key) throw new Error('APIキーを入力してください'); return key; }

/* ==== 直接API（ブラウザ） ==== */
async function runViaClient(key, raw, {max, since, sort}) {
  const channelId = await resolveChannelIdSmart(raw, key);
  if (!channelId) throw new Error('チャンネルIDを解決できませんでした');

  const [uploads, channel] = await Promise.all([
    getUploadsPlaylistId(channelId, key),
    fetchChannelInfo(channelId, key)
  ]);
  if (!uploads) throw new Error('アップロード済みプレイリストが見つかりませんでした');

  const videoIds = await listPlaylistVideoIds(uploads, key, max);
  const details  = await fetchVideosDetails(videoIds, key);
  let rows = videoIds.map((id, i) => {
    const d = details.get(id) || {};
    return {
      url:`https://www.youtube.com/watch?v=${id}`,
      viewCount:d.viewCount ?? null,
      likeCount:d.likeCount ?? null,
      commentCount:d.commentCount ?? null,
      title:d.title ?? '',
      publishedAt:d.publishedAt ?? '',
      channelId:d.channelId || '',
      __idx:i
    };
  });
  rows = applySinceAndSort(rows, { since, sort });
  return { rows, channel };
}

/* ==== GAS経由（取得モード用） ==== */
async function runViaGAS(appUrl, channelInput, {max, since, sort}){
  const url = new URL(appUrl);
  url.searchParams.set('max', String(max));
  if (since) url.searchParams.set('since', since);
  if (/^UC[0-9A-Za-z_-]{22}$/.test(channelInput)) url.searchParams.set('channelId', channelInput);
  else url.searchParams.set('channel', channelInput);

  try {
    const json = await fetchJson(url.toString());
    return normalizeFromBackend(json, sort, since);
  } catch (_) {
    const json = await jsonpFetch(url);
    return normalizeFromBackend(json, sort, since);
  }
}
function normalizeFromBackend(json, sort, since){
  if (!json || json.ok === false) throw new Error(json?.error || 'GAS応答エラー');
  let rows = (json.items || []).map((it,i) => ({
    url: it.url || '',
    viewCount: (it.viewCount != null) ? Number(it.viewCount) : null,
    likeCount: (it.likeCount != null) ? Number(it.likeCount) : null,
    commentCount: (it.commentCount != null) ? Number(it.commentCount) : null,
    title: it.title || '',
    publishedAt: it.publishedAt || '',
    channelId: it.channelId || '',
    __idx: i
  }));
  rows = applySinceAndSort(rows, { since, sort });
  const channel = json.channel ? {
    id: json.channel.id || '',
    title: json.channel.title || '',
    url: json.channel.url || '',
    subscriberCount: (json.channel.subscriberCount!=null)? Number(json.channel.subscriberCount):null,
    viewCount: (json.channel.viewCount!=null)? Number(json.channel.viewCount):null,
    videoCount: (json.channel.videoCount!=null)? Number(json.channel.videoCount):null,
    avatar: json.channel.avatar || ''
  } : null;
  return { rows, channel };
}

/* ==== 取得時の並び替え・フィルタ（公開日ベース） ==== */
function applySinceAndSort(rows, {since, sort}) {
  if (since) {
    const t0 = new Date(`${since}T00:00:00Z`).getTime();
    if (isFinite(t0)) rows = rows.filter(r => {
      const t = new Date(r.publishedAt || 0).getTime();
      return isFinite(t) && t >= t0;
    });
  }
  if (sort === 'newest' || sort === 'oldest') {
    rows.sort((a,b) => {
      const ta = new Date(a.publishedAt || 0).getTime();
      const tb = new Date(b.publishedAt || 0).getTime();
      return sort === 'newest' ? (tb - ta) : (ta - tb);
    });
  }
  return rows;
}

/* ==== 整形（テンプレ：上にチャンネル統計） ==== */
function rowsToFormattedText(rows, fmt, startNo, channel, winDays){
  const num = (i)=> String(Math.max(1, startNo|0) + i);
  const fmtNum = (n, unit='') => (n==null || isNaN(n)) ? '' : Number(n).toLocaleString('ja-JP')+unit;
  const fmtFloat = (n)=> (n==null || isNaN(n)) ? '' : (Math.round(n*10)/10).toLocaleString('ja-JP');
  const ch = channel || null;

  const headHtml = ch ? (() => {
    const sub = fmtNum(ch.subscriberCount, '人');
    const views = fmtNum(ch.viewCount, '回');
    const vids = fmtNum(ch.videoCount, '本');
    const name = escapeHtml(ch.title||'');
    const url  = ch.url || (ch.id ? `https://www.youtube.com/channel/${ch.id}`:'');
    const img  = ch.avatar ? `<img src="${ch.avatar}" alt="" style="width:48px;height:48px;border-radius:999px;vertical-align:middle;margin-right:8px">` : '';
    return `<section style="margin:0 10px 12px 0;padding:10px;border:1px solid #eee;border-radius:8px">
      <div style="display:flex;align-items:center;gap:8px">
        ${img}
        <div>
          <div style="font-weight:700;font-size:1.1rem"><a href="${url}" target="_blank" rel="noopener">${name}</a></div>
          <div style="color:#666;font-size:.9rem">登録者数：${sub || '-'}　総再生回数：${views || '-'}　動画数：${vids || '-'}</div>
        </div>
      </div>
    </section>`;
  })() : '';

  const viewLine = (r) => {
    const views = (r.viewCount!=null)? Number(r.viewCount).toLocaleString('ja-JP')+'回' : '-';
    const likes = (r.likeCount!=null)? Number(r.likeCount).toLocaleString('ja-JP') : '-';
    const comms = (r.commentCount!=null)? Number(r.commentCount).toLocaleString('ja-JP') : '-';
    const avg   = isNaN(r.__avgPerDay) ? '-' : `${fmtFloat(r.__avgPerDay)}/日`;
    const grow  = isNaN(r.__growthWin) ? '-' : `${Math.round(r.__growthWin).toLocaleString('ja-JP')}回/推定${winDays}日`;
    const date  = r.publishedAt ? r.publishedAt.slice(0,10) : '';
    return { views, likes, comms, avg, grow, date };
  };

  if (fmt === 'html-list' || fmt === 'html-cards') {
    if (fmt === 'html-list') {
      const items = rows.map((r,i)=>{
        const v = viewLine(r);
        return `<li style="margin:6px 0">
          <a href="${r.url}" target="_blank" rel="noopener" style="font-weight:600">${escapeHtml(r.title)}</a>
          — <a href="${r.url}" target="_blank" rel="noopener">${v.views}</a>
          — 👍 ${v.likes} — 💬 ${v.comms} — ${v.avg} — ${v.grow}
          — <span style="color:#666">${escapeHtml(v.date)}</span>
        </li>`;
      }).join('');
      return `${headHtml}<ol start="${Math.max(1, startNo|0)}" style="padding-left:1.4em">${items}</ol>`;
    } else {
      // html-cards
      const cards = rows.map((r,i)=>{
        const no = num(i);
        const v = viewLine(r);
        return `<div style="border:1px solid #eee;border-radius:10px;padding:10px">
          <div style="font-size:.9rem;color:#666">#${no}</div>
          <div style="font-weight:700;margin:2px 0 6px"><a href="${r.url}" target="_blank" rel="noopener">${escapeHtml(r.title)}</a></div>
          <div style="color:#444">
            <a href="${r.url}" target="_blank" rel="noopener">${v.views}</a>　|　👍 ${v.likes}　|　💬 ${v.comms}
          </div>
          <div style="color:#444">平均/日：${v.avg}　|　推定増分：${v.grow}</div>
          <div style="color:#666">${escapeHtml(v.date)}</div>
        </div>`;
      }).join('');
      return `${headHtml}<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(300px,1fr));gap:10px">${cards}</div>`;
    }
  }

  if (fmt === 'md') {
    const header = ch ? `## [${ch.title||''}](${ch.url || (ch.id?`https://www.youtube.com/channel/${ch.id}`:'')})
登録者数：${fmtNum(ch.subscriberCount)}　総再生回数：${fmtNum(ch.viewCount)}　動画数：${fmtNum(ch.videoCount)}
` : '';
    const lines = rows.map((r,i)=>{
      const v = viewLine(r);
      return `${num(i)}. [${r.title}](${r.url}) — [${v.views}](${r.url}) — 👍 ${v.likes} — 💬 ${v.comms} — 平均/日 ${v.avg} — 推定増分 ${v.grow} — ${v.date}`;
    }).join('\n');
    return header + lines;
  }

  // TSV / CSV
  const sep = (fmt==='csv') ? ',' : '\t';
  const esc = (s)=> {
    s = String(s??'');
    if (fmt==='csv' && /[",\n]/.test(s)) s = `"${s.replace(/"/g,'""')}"`;
    return s;
  };
  const head = ['No','URL','視聴回数','高評価','コメント','平均/日','推定増分(N日)','公開日','タイトル'];
  const channelRows = ch ? [
    ['Channel Title', ch.title || ''],
    ['Channel URL', ch.url || (ch.id?`https://www.youtube.com/channel/${ch.id}`:'')],
    ['Subscribers', ch.subscriberCount!=null? Number(ch.subscriberCount).toLocaleString('ja-JP') : ''],
    ['Total Views', ch.viewCount!=null? Number(ch.viewCount).toLocaleString('ja-JP') : ''],
    ['Video Count', ch.videoCount!=null? Number(ch.videoCount).toLocaleString('ja-JP') : ''],
    ['',''], // 空行
    head
  ] : [head];

  const lines = channelRows.map(r=>r.map(esc).join(sep));
  rows.forEach((r,i)=>{
    const v = viewLine(r);
    lines.push([num(i), r.url, v.views.replace('回',''), v.likes, v.comms, v.avg.replace('/日',''), v.grow.replace('回/推定'+winDays+'日',''), v.date, r.title].map(esc).join(sep));
  });
  return lines.join('\n');
}

/* ==== HTML用補助 ==== */
function escapeHtml(s){ return String(s).replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }

/* ==== テキストから動画ID抽出（整形モード） ==== */
function extractVideoIds(text){
  const set = new Set();
  const tokens = String(text||'').split(/[\s\n\r\t]+/).filter(Boolean);
  const re = /(?:v=|vi=|v%3D|youtu\.be\/|shorts\/|embed\/)([0-9A-Za-z_-]{11})/;
  for (const tk of tokens){
    if (/^https?:\/\//i.test(tk)) {
      try {
        const u = new URL(tk);
        const host = u.hostname.replace(/^www\./,'');
        const parts = u.pathname.replace(/\/+$/,'').split('/').filter(Boolean);
        let id = u.searchParams.get('v');
        if (!id && host==='youtu.be') id = parts[0];
        if (!id && ['shorts','embed','live'].includes(parts[0])) id = parts[1];
        if (id && /^[0-9A-Za-z_-]{11}$/.test(id)) { set.add(id); continue; }
      } catch {}
      const m = tk.match(re);
      if (m && m[1]) { set.add(m[1]); continue; }
    }
    if (/^[0-9A-Za-z_-]{11}$/.test(tk)) set.add(tk);
    else { const m = tk.match(re); if (m && m[1]) set.add(m[1]); }
  }
  return Array.from(set);
}

/* ==== Web API ==== */
async function fetchJson(u){
  const res = await fetch(u, {cache:'no-store',mode:'cors',credentials:'omit'});
  const ct  = (res.headers.get('content-type')||'').toLowerCase();
  const txt = await res.text();
  if (!res.ok) throw new Error(`HTTP ${res.status} / ${txt.slice(0,200)}`);
  if (!ct.includes('application/json')) throw new Error(`JSON以外の応答: ${ct} / ${txt.slice(0,160)}`);
  return JSON.parse(txt);
}
function jsonpFetch(urlObj){
  return new Promise((resolve,reject)=>{
    const u = new URL(urlObj.toString());
    const cb = '__jsonp_cb_' + Date.now() + '_' + Math.floor(Math.random()*1e6);
    u.searchParams.set('callback', cb);
    const timer = setTimeout(()=>{cleanup();reject(new Error('JSONPタイムアウト'));},15000);
    function cleanup(){clearTimeout(timer);try{delete window[cb];}catch{} if (script&&script.parentNode) script.parentNode.removeChild(script);}
    window[cb] = data => {cleanup();resolve(data);};
    const script = document.createElement('script');
    script.src = u.toString();
    script.onerror = ()=>{cleanup();reject(new Error('JSONP読込失敗'));};
    document.head.appendChild(script);
  });
}

/* ==== YouTube API 呼び出し ==== */
async function fetchChannelInfo(channelId, key){
  const ep = new URL('https://www.googleapis.com/youtube/v3/channels');
  ep.searchParams.set('part','snippet,statistics');
  ep.searchParams.set('id', channelId);
  ep.searchParams.set('key', key);
  const r = await fetch(ep); await assertOk_(r, 'channels(stats) API');
  const j = await r.json();
  const it = j.items?.[0];
  if (!it) return null;
  const sn = it.snippet || {}, st = it.statistics || {};
  return {
    id: it.id,
    title: sn.title || '',
    url: `https://www.youtube.com/channel/${it.id}`,
    avatar: sn.thumbnails?.default?.url || '',
    subscriberCount: st.subscriberCount!=null ? Number(st.subscriberCount) : null,
    viewCount:       st.viewCount!=null ? Number(st.viewCount) : null,
    videoCount:      st.videoCount!=null ? Number(st.videoCount) : null
  };
}

async function getChannelIdFromVideo(videoId, key) {
  const ep = new URL('https://www.googleapis.com/youtube/v3/videos');
  ep.searchParams.set('part','snippet');
  ep.searchParams.set('id', videoId);
  ep.searchParams.set('key', key);
  const r = await fetch(ep); await assertOk_(r, 'videos API');
  const j = await r.json();
  return j.items?.[0]?.snippet?.channelId || null;
}
async function getChannelIdFromPlaylist(playlistId, key) {
  const ep = new URL('https://www.googleapis.com/youtube/v3/playlists');
  ep.searchParams.set('part','snippet');
  ep.searchParams.set('id', playlistId);
  ep.searchParams.set('key', key);
  const r = await fetch(ep); await assertOk_(r, 'playlists API');
  const j = await r.json();
  return j.items?.[0]?.snippet?.channelId || null;
}
async function searchChannelIdByHandle(handle, key) {
  const ep = new URL('https://www.googleapis.com/youtube/v3/search');
  ep.searchParams.set('part','snippet');
  ep.searchParams.set('type','channel');
  ep.searchParams.set('q', handle);
  ep.searchParams.set('maxResults','1');
  ep.searchParams.set('key', key);
  const r = await fetch(ep); await assertOk_(r, 'search(handle) API');
  const j = await r.json();
  return j.items?.[0]?.id?.channelId || null;
}
async function searchChannelIdByQuery(query, key) {
  const ep = new URL('https://www.googleapis.com/youtube/v3/search');
  ep.searchParams.set('part','snippet');
  ep.searchParams.set('type','channel');
  ep.searchParams.set('q', query);
  ep.searchParams.set('maxResults','1');
  ep.searchParams.set('key', key);
  const r = await fetch(ep); await assertOk_(r, 'search(query) API');
  const j = await r.json();
  return j.items?.[0]?.id?.channelId || null;
}
async function getUploadsPlaylistId(channelId, key) {
  const ep = new URL('https://www.googleapis.com/youtube/v3/channels');
  ep.searchParams.set('part', 'contentDetails');
  ep.searchParams.set('id', channelId);
  ep.searchParams.set('key', key);
  const r = await fetch(ep); await assertOk_(r, 'channels API');
  const j = await r.json();
  return j.items?.[0]?.contentDetails?.relatedPlaylists?.uploads || null;
}
async function listPlaylistVideoIds(playlistId, key, maxCount) {
  let ids = []; let pageToken = '';
  while (ids.length < maxCount) {
    const ep = new URL('https://www.googleapis.com/youtube/v3/playlistItems');
    ep.searchParams.set('part', 'contentDetails');
    ep.searchParams.set('playlistId', playlistId);
    ep.searchParams.set('maxResults', '50');
    if (pageToken) ep.searchParams.set('pageToken', pageToken);
    ep.searchParams.set('key', key);
    const r = await fetch(ep); await assertOk_(r, 'playlistItems API');
    const j = await r.json();
    for (const it of (j.items || [])) {
      const id = it.contentDetails?.videoId;
      if (id) ids.push(id);
      if (ids.length >= maxCount) break;
    }
    pageToken = j.nextPageToken || '';
    if (!pageToken) break;
    setBusy(true, `取得中… ${ids.length}件`);
  }
  return ids;
}
async function fetchVideosDetails(videoIds, key) {
  const map = new Map();
  for (let i = 0; i < videoIds.length; i += 50) {
    const chunk = videoIds.slice(i, i + 50);
    const ep = new URL('https://www.googleapis.com/youtube/v3/videos');
    ep.searchParams.set('part', 'snippet,statistics');
    ep.searchParams.set('id', chunk.join(','));
    ep.searchParams.set('key', key);
    const r = await fetch(ep); await assertOk_(r, 'videos(details) API');
    const j = await r.json();
    for (const it of (j.items || [])) {
      map.set(it.id, {
        title: it.snippet?.title ?? '',
        viewCount: it.statistics?.viewCount != null ? Number(it.statistics.viewCount) : null,
        likeCount: it.statistics?.likeCount != null ? Number(it.statistics.likeCount) : null,
        commentCount: it.statistics?.commentCount != null ? Number(it.statistics.commentCount) : null,
        publishedAt: it.snippet?.publishedAt ?? '',
        channelId: it.snippet?.channelId || ''
      });
    }
  }
  return map;
}

/* ==== チャンネルID解決 ==== */
function looksLikeUrl(s){ return /^https?:\/\//i.test(String(s||'')); }
async function resolveChannelIdSmart(input, key) {
  const raw = String(input||'').trim(); if (!raw) return null;
  if (/^UC[0-9A-Za-z_-]{22}$/.test(raw)) return raw;
  if (/^[0-9A-Za-z_-]{11}$/.test(raw)) { const cid = await getChannelIdFromVideo(raw, key); if (cid) return cid; }
  if (raw.startsWith('@')) { const cid = await searchChannelIdByHandle(raw.slice(1), key); if (cid) return cid; }
  if (looksLikeUrl(raw)) {
    try {
      const u = new URL(raw);
      const host = u.hostname.replace(/^www\./,'');
      const parts = u.pathname.replace(/\/+$/,'').split('/').filter(Boolean);
      const vid = u.searchParams.get('v') || (['shorts','embed','live'].includes(parts[0]) ? parts[1] : null);
      if (host==='youtu.be' && parts[0]) { const cid = await getChannelIdFromVideo(parts[0].slice(0,11), key); if (cid) return cid; }
      if (vid) { const cid = await getChannelIdFromVideo(vid.slice(0,11), key); if (cid) return cid; }
      const list = u.searchParams.get('list'); if (list) { const cid = await getChannelIdFromPlaylist(list, key); if (cid) return cid; }
      const mCh = u.pathname.match(/\/channel\/(UC[0-9A-Za-z_-]{22})$/); if (mCh) return mCh[1];
      const mHandle = u.pathname.match(/\/@([^/]+)$/); if (mHandle) { const cid = await searchChannelIdByHandle(mHandle[1], key); if (cid) return cid; }
      const mCustom = u.pathname.match(/\/(c|user)\/([^/]+)$/); if (mCustom) { const cid = await searchChannelIdByQuery(mCustom[2], key); if (cid) return cid; }
    } catch {}
  }
  return await searchChannelIdByQuery(raw, key);
}

/* ==== ヘルパ ==== */
async function assertOk_(res, label){
  if (res.ok) return;
  let detail=''; try{ detail=' / '+(await res.text()).slice(0,200);}catch{}
  throw new Error(`${label} エラー: ${res.status}${detail}`);
}
function validateExecUrlOrThrow(s){
  const m = String(s||'').match(/https?:\/\/script\.google\.com\/macros\/s\/[A-Za-z0-9_-]+\/exec/);
  if (!m) throw new Error('GASの APP_URL（/exec）を正しく入力してください');
  return m[0];
}

/* ==== 便利ボタン ==== */
copyBtn.onclick = async () => {
  try { await navigator.clipboard.writeText(outTA.value); flash('コピーしました'); }
  catch { alert('コピーに失敗しました'); }
};
dlCsvBtn.onclick = () => {
  const text = outTA.value || '';
  const blob = new Blob([new Uint8Array([0xEF,0xBB,0xBF]), text.replace(/\t/g, ',')], { type: 'text/csv' });
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
  a.download = `youtube_${Date.now()}.csv`; document.body.appendChild(a); a.click(); a.remove();
};
</script>
